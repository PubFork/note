二分查找法
=

##### 必要条件：

1. 必须是一个数组
2. 数组中的值必须是有序的，从小到大排序的。

#### 原理：

在一个有序的数组中，要查找某个值在数组中的那个位置，最简单的方法就是从第一键值一直向最后一个键值遍历，直到找到这个值停止遍历。

这样的时间复杂度是O(N)，如果长度很大就会很费时间。

二分查找分，第一步是计算出一个中间值()(left + right) / 2)，根据这个中间值去对比要查找的值是大于还是小于中间值，来调整左边界和右边界的值。

这样即使的时间复杂度为O(logN)。

示例：

1 2 3 4 5 6，要在其中查找`6`是包含在其中。

`第一次查找`

left = 1，right = 6, mid = (1 + 6) / 2 = 3

对比中间值 3 和 6 的大小，3 比 6 小，所以要查找的值在右边，修改左边界的值为 mid + 1 = 4

需要在 4 5 6 中继续查找

`第二次查找`

left = 4 , right = 6 , mid = (4 + 6) / 2 = 5

5 小于 6 ，要找的值还是在右边，继续修改右边界的值为 mid + 1 = 6

需要在 6 中继续查找

`第三次查找`

left = 6, right = 6 , mid = (6 + 6 ) / 2 = 6

6 等于 6，这样就找到要找的值了。


---

这样就只循环了3次就能判断出6是否在这个数组中了，如果遍历查找要查找6次才能找到，节省了一半的循环时间，如果数组长度非常打，这个查找时间就很可观了。

注意：

移动左边界和右边界的时候，不能直接把中间值赋值过去，这样的话查找最后一个值的时候会进入死循环中。因为到最后中间值就会一直等于一个数不变无法跳出循环了。

利用上面的例子做个示例，如果直接把中间值直接赋值过去会发生什么吗？

`第一次查找`

left = 1，right = 6, mid = (1 + 6) / 2 = 3

`第二次查找`

left = 3, right = 6, mid = (3 + 6) / 2 = 4

`第三次查找`

left = 4, right = 6, mid = (4 + 6) / 2 = 5

`第四次查找`

left = 5, right = 6, mid = (5 + 6) / 2 = 5

`第五次查找`

left = 5, right = 6, mid = (5 + 6) / 2 = 5

开始进入死循环了，从第五次开始，左右值和中间变量都不会发生改变了。


C代码示例：

	#include <stdio.h>

	/*
 	* arr      有序数组
 	* value    要查找的值
 	* len      数组的长度
 	*/
	int BinarySearch(const int arr[],int value,int len){
    	int left,right,mid;
    	left = 1;
    	right = len;
    	while(left <= right){
        	mid = (left + right) / 2;
        	if(value < arr[mid - 1])
        	    right = mid - 1;
        	else if(value > arr[mid - 1])
        	    left = mid + 1;
        	else
           	 return mid;
   	 }
    	return 0;
	}

	int main(void){
    	int arr[] = {1,2,3,4,5,6};
    	int pos = 0;
    	if((pos = BinarySearch(arr,6,6))){
     	   printf("pos = %d\n",pos);
    	}else{
    	    printf("not search\n");
   	 }
	}
