基础类型
=
1. 布尔型: bool
长度：1字节
取值范围：true，false
注意事项：不可以用数字代表true和false

2. 整型：int/uint
根据运行平台可能为32或64位

3. 8位整型：int8/uint8
长度：1字节
取值范围：-128~127/0-255

4. 字节型：byte(uint8别名)

5. 16位整型：int16/uint16
长度：2字节
取值范围：-32768~32767/0-65535

6. 32位整型：int32(rune)/uint32
长度：4字节
取值范围：-2^32/2~2^32/2|0~2^32-1
7. 64位整型：int64(rune)/uint64
长度：8字节
取值范围：-2^64/2~2^64/2|0~2^64-1

8. 浮点型：float32/float64
长度：4/8字节
小数位：精确到7/15位数
浮点型的比较，浮点型不是一种精确的表达方式，所以想整型那样使用==来判断不可行，这会导致不稳定的结果

9. 字符串
GO中的字符串是一种基本类型，和C不一样，C是利用数组来实现字符串类型，而GO则是语言层面支持字符串。
字符串赋值后是不能修改的，负责是会报编译错误
例如
str := "my name is wolf"
str[0] = 'y' 这句会报错

str = "my name is leloup"  这句虽然可以打印正确，表面上看是修改了字符串，其实不然，这只是修改了指向的内存地址，而不是修改了原来的字符串，可以使用fmt


10. 复数：complex64/complex128
长度：8/16字节

11. 足够保存指针的32位或64位整数型：uintptr

12. 其他类型：
	array、struct、string

13. 引用类型：
	slice、map、chan

14. 接口类型：interface

15. 函数类型：func

类型的默认值
=
在定义一个变量类型时候，如果没有初始化，不同类型的变量GO会设置不同的默认值。
1. 整型默认是为0
2. 字符串类型默认为空
3. 布尔型默认为false
4. 数组默认为空数组

变量的声明
=
go语言的变量声明很智能，有很多种方法。
1. var a int 
2. a = 123
3. a:= 123
注意：在声明全局变量的时候必须使用var来定义变量，全局变量有以下几种方法定义
1. var p = 2		定义并初始化该变量
2. var p int		定义一个整型变量
3. var p int = 3	定义一个整型变量并声明类型，这种方式初始化的时候赋值必须写在类型名后面
4. var (			多个全局变量的赋值
		p = 2
		z = 1
	   )

多个变量的声明与赋值
1. 全局变量可以使用var()的方式简写
2. 局部变量进行多个赋值要使用并行的方式,var()也可以但是不建议使用。
例如
var a,b [int] = 1,2
a,b := 1,2 省略var关键字的时候必须使用":"冒号赋值

变量类型的转换
=
Go中的类型转换必须要显示声明，而且必须要2个类型相互兼容。

常量的赋值
=
注意：常量表达式的赋值必须是内置函数或常量，不可以把变量赋值给常量，因为常量表达式实在编译阶段处理的这时候还没有处理变量。

枚举型
=

数组:array
=
array由[n]<type>定义，n标示array的长度，而<type>表示希望存储内容的类型。对array的元素赋值或所以是由方括号完成的。数组的长度在定义后不可修改。

数组是值类型的，讲一个数组赋值给另一个数组，会复制所有的元素。尤其是向函数内传递一个数组的时候，会获得一个数组的副本，而不是数组的指针。

数组的声明

	var arr [3]int
	
	arr := [3]int{1,2,3}
	
	arr := [...]int{1,2,3}				初始化的时候，让Go去自动计算长度则可以使用...符号来表示。
	
	arr := [2][2]inti{{1,2},{3,4}}		多维数组的初始化

切片：slice
=

slice与array接近，但是slice在新元素加入的时候可以`增加长度`。

slice是一个指向array的`指针`。slice是`引用类型`的，表示在赋值给另一个变量时，两个引用会指向同一个array，不管那个变量修改了，都相当于**修改了指向的那个数组**。在函数传递参数时，也是一个传递一个引用，所有修改会影响其参数。

声明：

	sl := make([]int,10)		创建了一个有10个元素的slice。
	 
	s1 := []int{1,2,3}			这事创建了一个切片而不是数组，s1 := [...]int{1,2,3} 这个才是创建了一个数组
	
	s1 := arr[:4]				根据数组来创建一个切片

######向切片中追加数组可以使用append函数

	s1 := []int{1,2,3}	

	s2 := append(s1,1) 向s1追加值为1的数据，如果要追加一个数组则不能这样使用 
	
	append(s1,arr),这样会出错因为s1是int类型所以传入一个数组是不行的，要使用
	
	append(s1,arr...)，加上...符号相当于把arr打散后传入
	
`注意:`

1. **append()**函数会根据原切片变量的长度增加一倍，新的切片长度是根据**cap()**函数返回值的2倍
2. **append()**返回的新的切片指向到了一个新的内存地址，不再指向原来的内存空间。也就是说再修改新的切片不会影响到它之前指向的那个数组的值。

例如：

	var arr = [...]int{1, 2, 3}
	
	s1 := arr[0:2]	//值为1, 2
	
	s1[0] = 10		//arr[0] 的值也变为10
	
	newS1 := append(s1, 4)	
	
	newS1[0] = 100	//这次不会再修改arr[0]的值了


######复制切片

使用copy函数把一个切片赋值到另一个切片中。

	var arr = [...]int{1, 2, 3, 4, 5}
	
	src := arr[0:2]
	
	dest := arr[2:]
	
	copy(src,dest)
	
	fmt.Println(src)	//3, 4
	
	fmt.Println(dest)	// 3, 4, 5

copy(src, dest) 把dest的数据复制到src中，注意相同键值会被第二个参数`覆盖`，而不是`追加`，比如s1中的数据是1，2，3，4，5而s2是6，7，8，使用copy后s1的数据就是6，7，8，4，5

map
=
声明：

	var myMap map[string] int
	
	myMap := make(map[string] ,int)

`string是键值的类型、int是所存放的类型值`



######元素删除

使用`delete函数`来删除某个元素。

delete(myMap,"ab") 删除键值为ab的元素

######元素查找

在GO中，查找某个键值是否存在
val,ok := myMap["ab"]
if ok{
	fmt.Println(val)
}

